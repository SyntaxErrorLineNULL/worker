package worker

import (
	"context"
	"sync"
	"testing"
	"time"

	wr "github.com/SyntaxErrorLineNULL/worker"
	"github.com/SyntaxErrorLineNULL/worker/mocks"
	"github.com/stretchr/testify/assert"
)

func TestWorker(t *testing.T) {
	t.Parallel()

	// Create a new mock task instance for testing.
	// This mock task is generated by the testing framework to simulate the behavior of a real task object.
	// It allows you to control and verify how your code interacts with the task, without relying on actual task execution.
	mockTask := mocks.NewTask(t)
	// Verify that the mock task instance is not nil.
	// The assert statement checks that the mock task was successfully created and is not a zero value.
	// If the mock task is nil, it indicates that the mock creation process failed, which would invalidate the test.
	assert.NotNil(t, mockTask, "Mock task should be successfully created and not be nil")

	// Create a WaitGroup to manage synchronization of the worker's goroutine.
	// This allows the test to wait for the worker to complete its execution.
	wg := &sync.WaitGroup{}

	// InitWorker tests the initialization of a Worker instance.
	// It verifies that the worker is properly created with the expected initial values
	// and that all required channels are initialized. This test ensures that
	// the worker is correctly set up with the specified ID, timeout, and initial status.
	t.Run("InitWorker", func(t *testing.T) {
		// Create a new Worker instance with ID 1, a timeout of 1 second, and a logger.
		// This initializes the worker with specified parameters and ensures that it is properly set up.
		worker := NewWorker(1)
		// Assert that the worker instance is not nil.
		// This checks that the worker was successfully created and is not a zero value.
		assert.NotNil(t, worker, "Worker should be successfully created")

		// Assert that the worker's ID is set to 1.
		// This verifies that the worker has been initialized with the correct ID.
		assert.Equal(t, int64(1), worker.workerID, "Worker ID should be 1")

		// Assert that the worker's status is initially set to `StatusWorkerIdle`.
		// This confirms that the worker starts in an idle state, ready to process jobs.
		assert.Equal(t, wr.StatusWorkerIdle, worker.GetStatus(), "Worker status should be idle initially")

		// Assert that the worker's stop channel is not nil.
		// This checks that the stop channel is correctly created as part of the worker's initialization.
		assert.NotNil(t, worker.stopCh, "Worker stop channel should be created")

		// Assert that the worker's error channel is not nil.
		// This verifies that the error channel is correctly initialized, allowing the worker to report errors.
		assert.NotNil(t, worker.errCh, "Worker error channel should be created")
	})

	// SetQueue tests the SetQueue method of the Worker type.
	// It verifies that the method correctly handles setting both open and closed channels as the task queue.
	// The test ensures that setting an open channel succeeds, while setting a closed channel produces an error,
	// validating proper queue management within the worker.
	t.Run("SetQueue", func(t *testing.T) {
		// Create a new Worker instance with ID 1, a timeout of 1 second, and a logger.
		// This initializes the worker with specified parameters and ensures that it is properly set up.
		worker := NewWorker(1)
		// Assert that the worker instance is not nil.
		// This checks that the worker was successfully created and is not a zero value.
		assert.NotNil(t, worker, "Worker should be successfully created")

		// Create an open channel to be used as a task queue.
		// This channel is not closed and should be valid for use in the worker.
		openCh := make(chan wr.Task)

		// Set the worker's queue to the open channel.
		// This tests that the worker can successfully use the open channel as its job queue.
		err := worker.SetQueue(openCh)
		// Assert that no error is returned when setting an open channel.
		// This confirms that setting an open channel is handled correctly by the worker.
		assert.NoError(t, err, "Setting an open channel should not produce an error")

		// Create a new channel of type interfaces Task.
		// This channel will be used to test the `SetQueue` method with a closed channel scenario.
		closedChan := make(chan wr.Task)

		// Close the channel to simulate a scenario where the channel is no longer open for receiving tasks.
		// Closing the channel makes it an invalid queue for the worker, which should trigger an error when set.
		close(closedChan)

		// Attempt to set the worker's queue to the closed channel.
		// This action simulates a scenario where an invalid (closed) channel is used as the workerâ€™s job queue.
		err = worker.SetQueue(closedChan)
		// Assert that an error is returned when setting a closed channel.
		// This verifies that the worker's SetQueue method correctly handles and reports an error for closed channels.
		assert.Error(t, err, "Setting a closed channel should produce an error")
	})

	// SetContext tests the SetContext method of the Worker type.
	// It verifies that the worker's context is correctly set and that setting a nil context
	// does not change the existing context. This test ensures proper behavior when managing
	// the worker's context during its lifecycle.
	t.Run("SetContext", func(t *testing.T) {
		// Create a new Worker instance with ID 1, a timeout of 1 second, and a logger.
		// This initializes the worker with specified parameters and ensures that it is properly set up.
		worker := NewWorker(1)
		// Assert that the worker instance is not nil.
		// This checks that the worker was successfully created and is not a zero value.
		assert.NotNil(t, worker, "Worker should be successfully created")

		// Create a new background context for testing.
		// This context will be used to set and verify the worker's context.
		ctx := context.Background()

		// Set the worker's context to the new background context.
		// This tests the SetContext method by providing a valid context.
		err := worker.SetContext(ctx)
		// Assert that no error occurred when setting the context.
		// This ensures that the SetContext method works as expected when a valid context is provided.
		assert.NoError(t, err, "Expected no error when setting a valid context")
		// Assert that the worker's context is set correctly.
		// This checks that the worker's context matches the provided context after setting it.
		assert.Equal(t, ctx, worker.workerContext, "Worker context should be set to the provided context")

		// Attempt to set the worker's context to nil.
		// This tests the SetContext method's handling of invalid input.
		err = worker.SetContext(nil)
		// Assert that an error occurred when trying to set a nil context.
		// This verifies that the method correctly returns an error for invalid input.
		assert.Error(t, err, "Expected an error when setting a nil context")

		// Assert that the worker's context remains unchanged after attempting to set a nil context.
		// This verifies that the context does not get altered if a nil value is provided.
		assert.Equal(t, ctx, worker.workerContext, "Worker context should remain unchanged when setting a nil context")
	})

	// GetStatusWithRun tests the behavior of a worker as it transitions through its lifecycle stages.
	// The test verifies that the worker can correctly initialize, process jobs, and handle context
	// cancellation. It checks that the worker starts in an idle state, transitions to running, and
	// eventually stops as expected. Additionally, the test ensures that the worker's error channel
	// is properly closed upon termination and that all goroutines complete without issues.
	t.Run("GetStatusWithRun", func(t *testing.T) {
		// Create a context with cancellation to manage the lifecycle of the worker and ensure proper cleanup.
		// The context will allow the worker to be cancelled if necessary.
		ctx, cancel := context.WithCancel(context.Background())
		// Ensure that the context cancellation function is called at the end of the test.
		// This prevents resource leaks by ensuring proper cleanup after the test completes.
		defer cancel()

		// Create a new Worker instance with ID 1, a timeout of 1 second, and a logger.
		// This initializes the worker with specified parameters and ensures that it is properly set up.
		worker := NewWorker(1)
		// Assert that the worker instance is not nil.
		// This checks that the worker was successfully created and is not a zero value.
		assert.NotNil(t, worker, "Worker should be successfully created")

		// Set the worker's context to the new background context.
		// This tests the SetContext method by providing a valid context.
		err := worker.SetContext(ctx)
		// Assert that no error occurred when setting the context.
		// This ensures that the SetContext method works as expected when a valid context is provided.
		assert.NoError(t, err, "Expected no error when setting a valid context")

		// Create a channel with a buffer size of 1 to receive tasks.
		// This channel will be used as the job queue for the worker.
		taskQueue := make(chan wr.Task, 1)

		// Set the worker's queue to the open channel.
		// This tests that the worker can successfully use the open channel as its job queue.
		err = worker.SetQueue(taskQueue)
		// Assert that no error is returned when setting an open channel.
		// This confirms that setting an open channel is handled correctly by the worker.
		assert.NoError(t, err, "Setting an open channel should not produce an error")

		// Increment the WaitGroup counter by 1 to account for the worker's goroutine.
		// This is necessary to properly synchronize the test's main goroutine with the worker's goroutine.
		wg.Add(1)
		// Start the worker in a separate goroutine to allow it to run concurrently.
		// The worker will begin processing tasks in this goroutine.
		go worker.Start(wg)

		// Sleep for a short duration to allow the worker to transition to its initial state.
		// This delay simulates the time needed for the worker to initialize.
		time.Sleep(30 * time.Millisecond)

		// Assert that the worker's initial status is idle.
		// This ensures that the worker is in the expected initial state before processing any jobs.
		assert.Equal(t, wr.StatusWorkerIdle, worker.GetStatus(), "Worker should be idle after starting")

		// Sleep for a short duration to allow the worker to potentially transition to a running state.
		// This provides additional time for the worker to change its status if it starts processing.
		time.Sleep(30 * time.Millisecond)

		// Wait for the worker to stop or time out.
		// This block manages the completion of the worker's lifecycle and handles any potential delays.
		select {
		case <-worker.Stop():
			// Worker completed successfully.
			// Any assertions or checks can be placed here if needed.
			assert.Equal(t, wr.StatusWorkerStopped, worker.GetStatus(), "Expected worker status to be stopped")

			// Attempt to read from the worker's error channel.
			// This checks whether the channel is closed after the worker has stopped.
			_, ok := <-worker.errCh
			// Assert that the error channel is closed by verifying that the 'ok' value is false.
			// If 'ok' is false, it indicates that the channel is closed, meaning no further errors can be received.
			assert.False(t, ok, "Error channel should be closed after worker stops")

		case <-time.After(2 * time.Second):
			t.Error("Worker did not stop within the expected time.")
		}
	})

	// ContextDone tests the worker's behavior when its context is canceled. The test verifies that the worker
	// can properly initialize, process a task, and handle context cancellation. It ensures that the worker
	// correctly transitions to the 'stopped' state upon context cancellation, that its processing state is
	// cleaned up, and that the worker stops within the expected time.
	t.Run("ContextDone", func(t *testing.T) {
		// Create a context with cancellation to manage the lifecycle of the worker and ensure proper cleanup.
		// The context will allow the worker to be cancelled if necessary.
		ctx, cancel := context.WithCancel(context.Background())

		// Create a new Worker instance with ID 1, a timeout of 1 second, and a logger.
		// This initializes the worker with specified parameters and ensures that it is properly set up.
		worker := NewWorker(1)
		// Assert that the worker instance is not nil.
		// This checks that the worker was successfully created and is not a zero value.
		assert.NotNil(t, worker, "Worker should be successfully created")

		// Set the worker's context to the new background context.
		// This tests the SetContext method by providing a valid context.
		err := worker.SetContext(ctx)
		// Assert that no error occurred when setting the context.
		// This ensures that the SetContext method works as expected when a valid context is provided.
		assert.NoError(t, err, "Expected no error when setting a valid context")

		// Create a channel with a buffer size of 1 to receive tasks.
		// This channel will be used as the job queue for the worker.
		taskQueue := make(chan wr.Task, 1)

		// Set the worker's queue to the open channel.
		// This tests that the worker can successfully use the open channel as its job queue.
		err = worker.SetQueue(taskQueue)
		// Assert that no error is returned when setting an open channel.
		// This confirms that setting an open channel is handled correctly by the worker.
		assert.NoError(t, err, "Setting an open channel should not produce an error")

		// Set up the mock task to expect a Run call and return without error.
		// This simulates the worker processing the task.
		mockTask.EXPECT().Run().Return()

		// Expect the mock task to have its WaitGroup set to the one created above.
		// This allows synchronization between the task and the worker's lifecycle.
		mockTask.EXPECT().SetWaitGroup(wg).Return(nil)

		// Send the mock task to the worker's task queue.
		// This simulates the worker receiving a task for processing.
		taskQueue <- mockTask

		// Increment the WaitGroup counter by 1 to account for the worker's goroutine.
		// This is necessary to properly synchronize the test's main goroutine with the worker's goroutine.
		wg.Add(1)

		// Start the worker in a separate goroutine to allow it to run concurrently.
		// The worker will begin processing tasks in this goroutine.
		go worker.Start(wg)

		// Wait for 100 millisecond to allow the worker to process the job.
		// This delay provides sufficient time for the worker to handle the job before canceling the context.
		time.Sleep(100 * time.Millisecond)

		// Cancel the context to signal the worker to stop processing.
		// This action is used to test if the worker responds correctly to context cancellation.
		cancel()

		// Wait for the worker to stop processing and check its status.
		// This block waits for either the worker to signal that it has stopped or a timeout to occur.
		select {
		case <-worker.stopCh:
			// Assert that the worker status is 'stopped' after cancellation.
			// This verifies that the worker correctly transitions to the 'stopped' state.
			assert.Equal(t, wr.StatusWorkerStopped, worker.GetStatus(), "Expected worker status to be stopped")

			// Assert that the `process` field of the `worker` is `nil`.
			// This ensures that the worker has not started processing or has properly cleaned up its processing state.
			assert.Nil(t, worker.currentProcess, "Expected worker.process to be nil, indicating that the worker has not started processing or has been properly cleaned up.")

		case <-time.After(5 * time.Second):
			// Timeout case: if the pool does not stop within the expected time, indicate a test failure.
			t.Error("Failed to stop worker within expected time")
		}
	})

	// SuccessStop tests the `Stop` method of the Worker struct to ensure that the worker
	// transitions to the 'stopped' state properly. It verifies that the worker's status
	// is updated to 'stopped', and that both the error channel and stop channel are closed
	// as expected when the worker has finished stopping.
	t.Run("SuccessStop", func(t *testing.T) {
		// Create a background context for the worker.
		// This context will manage the worker's lifecycle and cancellation signals.
		ctx := context.Background()

		// Create a new Worker instance with ID 1, a timeout of 1 second, and a logger.
		// This initializes the worker with specified parameters and ensures that it is properly set up.
		worker := NewWorker(1)
		// Assert that the worker instance is not nil.
		// This checks that the worker was successfully created and is not a zero value.
		assert.NotNil(t, worker, "Worker should be successfully created")

		// Set the worker's context to the new background context.
		// This tests the SetContext method by providing a valid context.
		err := worker.SetContext(ctx)
		// Assert that no error occurred when setting the context.
		// This ensures that the SetContext method works as expected when a valid context is provided.
		assert.NoError(t, err, "Expected no error when setting a valid context")

		// Create a channel with a buffer size of 1 to receive tasks.
		// This channel will be used as the job queue for the worker.
		taskQueue := make(chan wr.Task, 1)

		// Set the worker's queue to the open channel.
		// This tests that the worker can successfully use the open channel as its job queue.
		err = worker.SetQueue(taskQueue)
		// Assert that no error is returned when setting an open channel.
		// This confirms that setting an open channel is handled correctly by the worker.
		assert.NoError(t, err, "Setting an open channel should not produce an error")

		select {
		// Wait for the worker to signal that it has stopped.
		// The `select` statement is used to wait for signals from the worker's stop channel,
		// ensuring that we handle the stop notification correctly and verify the worker's status.
		case <-worker.Stop():
			// Assert that the worker status is 'stopped' after cancellation.
			// This verifies that the worker correctly transitions to the 'stopped' state.
			assert.Equal(t, wr.StatusWorkerStopped, worker.GetStatus(), "Expected worker status to be stopped")

			// Check if the error channel is closed after the worker stops.
			// Receiving from the worker's error channel to see if it is closed.
			// If the error channel is closed, the worker has finished processing and has cleaned up resources.
			_, ok := <-worker.GetError()
			// Assert that the channel is closed (`ok` is false), indicating that no further errors are being sent.
			// A closed error channel suggests that the worker has properly finished its execution without outstanding errors.
			assert.False(t, ok, "Error channel should be closed after worker stops")

			select {
			// Wait for the worker's stop channel to confirm it is closed.
			// The stop channel should be closed as part of the worker's shutdown process.
			// We use this to ensure that the worker has completed all shutdown activities and no further signals will be sent.
			case <-worker.stopCh:
				// Attempt to read from the stop channel to verify that it's closed.
				// Since the channel should be closed, the read operation should succeed and return the zero value of the channel's type.
				_, ok = <-worker.stopCh
				// Assert that the stop channel is indeed closed.
				// If the channel is closed, `ok` should be false, confirming that the worker has fully stopped and cleaned up.
				assert.False(t, ok, "Stop channel should be closed after worker stops")
			}

		case <-time.After(2 * time.Second):
			// If the worker does not stop within the allocated 2 seconds, this block will execute.
			// This indicates that the worker took too long to stop, which could signify a problem with the shutdown process.
			// The test will fail, providing feedback that the worker did not stop as expected within the given time frame.
			t.Error("Failed to stop worker within expected time")
		}
	})

	// WorkerPanic test case ensures that a Worker instance can handle and report a panic
	// that occurs during the execution of a task. This is crucial for validating the robustness
	// of the worker's error handling mechanism, especially in scenarios where unexpected
	// panics might occur. The test verifies that the worker catches the panic, reports the
	// appropriate error, and associates the error with the correct worker instance.
	t.Run("WorkerPanic", func(t *testing.T) {
		// Create a background context for the worker.
		// This context will manage the worker's lifecycle and cancellation signals.
		ctx := context.Background()

		// Create a new Worker instance with ID 1, a timeout of 1 second, and a logger.
		// This initializes the worker with specified parameters and ensures that it is properly set up.
		worker := NewWorker(1)
		// Assert that the worker instance is not nil.
		// This checks that the worker was successfully created and is not a zero value.
		assert.NotNil(t, worker, "Worker should be successfully created")

		// Set the worker's context to the new background context.
		// This tests the SetContext method by providing a valid context.
		err := worker.SetContext(ctx)
		// Assert that no error occurred when setting the context.
		// This ensures that the SetContext method works as expected when a valid context is provided.
		assert.NoError(t, err, "Expected no error when setting a valid context")

		// Create a channel with a buffer size of 1 to receive tasks.
		// This channel will be used as the job queue for the worker.
		taskQueue := make(chan wr.Task, 1)

		// Set the worker's queue to the open channel.
		// This tests that the worker can successfully use the open channel as its job queue.
		err = worker.SetQueue(taskQueue)
		// Assert that no error is returned when setting an open channel.
		// This confirms that setting an open channel is handled correctly by the worker.
		assert.NoError(t, err, "Setting an open channel should not produce an error")

		// Create an instance of MockPanicTask, which simulates a task that will panic during its execution.
		// This mock task is used to test the worker's panic handling capabilities.
		mockPanicTask := &MockPanicTask{}

		// Send the mock panic task to the worker's task queue.
		// This simulates the worker receiving a task that will cause a panic when executed.
		taskQueue <- mockPanicTask

		// Increment the WaitGroup counter by 1 to account for the worker's goroutine.
		// This is necessary to properly synchronize the test's main goroutine with the worker's goroutine.
		wg.Add(1)

		// Start a new goroutine to handle the delayed start of the worker.
		// This goroutine allows the worker to begin processing tasks independently of the main test execution.
		go func() {
			// Introduce a delay of 1 second before starting the worker.
			// This delay simulates a real-world scenario where the worker might not start immediately after initialization.
			<-time.After(1 * time.Second)

			// Begin the worker's task processing.
			// The worker will start processing tasks from its queue and handle any errors or panics that occur.
			// The `wg` (WaitGroup) is passed to ensure that the test waits for the worker to finish before proceeding.
			worker.Start(wg)
		}()

		select {
		// Wait for the worker to handle the task and check for errors or a timeout.
		// This select block listens for the worker to signal that it encountered an error or waits for a timeout.
		case workerError := <-worker.GetError():
			// Assert that the error received is the expected panic error.
			// This verifies that the worker correctly identified and reported the panic error.
			assert.ErrorIs(t, workerError.Error, ErrorMockPanic)
			// Assert that the error instance matches the worker that encountered the error.
			// This confirms that the correct worker is associated with the reported error.
			assert.Equal(t, worker, workerError.Instance)

		case <-time.After(5 * time.Second):
			// If the worker does not stop within the allocated 5 seconds, this block will execute.
			// This indicates that the worker took too long to stop, which could signify a problem with the shutdown process.
			// The test will fail, providing feedback that the worker did not stop as expected within the given time frame.
			t.Error("Failed to stop worker within expected time")
		}

	})
}
