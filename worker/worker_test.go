package worker

import (
	"context"
	"runtime"
	"sync"
	"testing"
	"time"

	wr "github.com/SyntaxErrorLineNULL/worker"
	"github.com/SyntaxErrorLineNULL/worker/mocks"
	"github.com/stretchr/testify/assert"
)

func TestWorker(t *testing.T) {
	t.Parallel()

	defer runtime.GC()

	// Create a new mock task instance for testing.
	// This mock task is generated by the testing framework to simulate the behavior of a real task object.
	// It allows you to control and verify how your code interacts with the task, without relying on actual task execution.
	mockTask := mocks.NewTask(t)
	// Verify that the mock task instance is not nil.
	// The assert statement checks that the mock task was successfully created and is not a zero value.
	// If the mock task is nil, it indicates that the mock creation process failed, which would invalidate the test.
	assert.NotNil(t, mockTask, "Mock task should be successfully created and not be nil")

	// Create a WaitGroup to manage synchronization of the worker's goroutine.
	// This allows the test to wait for the worker to complete its execution.
	wg := &sync.WaitGroup{}

	// InitWorker tests the initialization of a Worker instance.
	// It verifies that the worker is properly created with the expected initial values
	// and that all required channels are initialized. This test ensures that
	// the worker is correctly set up with the specified ID, timeout, and initial status.
	t.Run("InitWorker", func(t *testing.T) {
		// Define a name for the worker to be used in this test.
		// This name is used to initialize and identify the worker instance.
		workerName := "workerName"

		// Create a new Worker instance with the specified name.
		// The NewWorker function initializes a worker with a unique name and default settings.
		// The worker is expected to be properly set up with a timeout and a logger.
		worker := NewWorker(workerName)
		// Assert that the worker instance is not nil.
		// This checks that the worker was successfully created and is not a zero value.
		assert.NotNil(t, worker, "Worker should be successfully created")

		// Assert that the worker's name is correctly set to the given name.
		// The String method returns the worker's name, which should match the provided workerName.
		// This confirms that the worker's name was initialized correctly.
		assert.Equal(t, workerName, worker.String(), "Worker name should match the provided name")

		// Assert that the worker's status is initially set to `StatusWorkerIdle`.
		// This confirms that the worker starts in an idle state, ready to process jobs.
		assert.Equal(t, wr.StatusWorkerIdle, worker.GetStatus(), "Worker status should be idle initially")

		// Assert that the worker's stop channel is not nil.
		// This checks that the stop channel is correctly created as part of the worker's initialization.
		assert.NotNil(t, worker.stopCh, "Worker stop channel should be created")
	})

	// SetQueue tests the SetQueue method of the Worker type.
	// It verifies that the method correctly handles setting both open and closed channels as the task queue.
	// The test ensures that setting an open channel succeeds, while setting a closed channel produces an error,
	// validating proper queue management within the worker.
	t.Run("SetQueue", func(t *testing.T) {
		// Define a name for the worker to be used in this test.
		// This name is used to initialize and identify the worker instance.
		workerName := "workerName"

		// Create a new Worker instance with the specified name.
		// The NewWorker function initializes a worker with a unique name and default settings.
		// The worker is expected to be properly set up with a timeout and a logger.
		worker := NewWorker(workerName)
		// Assert that the worker instance is not nil.
		// This checks that the worker was successfully created and is not a zero value.
		assert.NotNil(t, worker, "Worker should be successfully created")

		// Create an open channel to be used as a task queue.
		// This channel is not closed and should be valid for use in the worker.
		openCh := make(chan wr.Task)

		// Set the worker's queue to the open channel.
		// This tests that the worker can successfully use the open channel as its job queue.
		err := worker.SetQueue(openCh)
		// Assert that no error is returned when setting an open channel.
		// This confirms that setting an open channel is handled correctly by the worker.
		assert.NoError(t, err, "Setting an open channel should not produce an error")

		// Create a new channel of type interfaces Task.
		// This channel will be used to test the `SetQueue` method with a closed channel scenario.
		closedChan := make(chan wr.Task)

		// Close the channel to simulate a scenario where the channel is no longer open for receiving tasks.
		// Closing the channel makes it an invalid queue for the worker, which should trigger an error when set.
		close(closedChan)

		// Attempt to set the worker's queue to the closed channel.
		// This action simulates a scenario where an invalid (closed) channel is used as the worker’s job queue.
		err = worker.SetQueue(closedChan)
		// Assert that an error is returned when setting a closed channel.
		// This verifies that the worker's SetQueue method correctly handles and reports an error for closed channels.
		assert.Error(t, err, "Setting a closed channel should produce an error")
	})

	// SetErrorChannel tests the behavior of the worker when setting an error channel.
	// This test ensures that the worker can correctly handle both open and closed channels.
	// It verifies that setting an open channel does not produce errors, while setting
	// a closed channel results in an appropriate error. This is crucial for the robustness
	// of the worker's error handling mechanism, ensuring that it can gracefully handle
	// erroneous conditions related to its error channel.
	t.Run("SetErrorChannel", func(t *testing.T) {
		// Define a name for the worker to be used in this test.
		// This name is used to initialize and identify the worker instance.
		workerName := "workerName"

		// Create a new Worker instance with the specified name.
		// The NewWorker function initializes a worker with a unique name and default settings.
		// The worker is expected to be properly set up with a timeout and a logger.
		worker := NewWorker(workerName)
		// Assert that the worker instance is not nil.
		// This checks that the worker was successfully created and is not a zero value.
		assert.NotNil(t, worker, "Worker should be successfully created")

		// Create an open channel to be used as the worker's error channel.
		// This channel will be used to test the worker's handling of a valid error channel.
		openCh := make(chan *wr.Error)

		// Set the worker's queue to the open channel.
		// This tests that the worker can successfully use the open channel as its job queue.
		err := worker.SetWorkerErrChannel(openCh)
		// Assert that no error is returned when setting an open channel.
		// This confirms that setting an open channel is handled correctly by the worker.
		assert.NoError(t, err, "Setting an open channel should not produce an error")

		// Create a closed channel to simulate an invalid error channel scenario.
		// This closed channel will be used to test the worker's handling of an invalid (closed) error channel.
		closedChan := make(chan *wr.Error)

		// Close the channel to simulate an invalid (closed) error channel.
		// This action is used to create a scenario where the channel is no longer usable,
		// effectively testing how the worker handles setting a closed channel as its error channel.
		close(closedChan)

		// Attempt to set the worker's queue to the closed channel.
		// This action simulates a scenario where an invalid (closed) channel is used as the worker’s job queue.
		err = worker.SetWorkerErrChannel(closedChan)
		// Assert that an error is returned when setting a closed channel.
		// This verifies that the worker's SetQueue method correctly handles and reports an error for closed channels.
		assert.Error(t, err, "Setting a closed channel should produce an error")
	})

	// SetContext tests the SetContext method of the Worker type.
	// It verifies that the worker's context is correctly set and that setting a nil context
	// does not change the existing context. This test ensures proper behavior when managing
	// the worker's context during its lifecycle.
	t.Run("SetContext", func(t *testing.T) {
		// Create a new Worker instance with a unique name, a timeout of 1 second, and a logger.
		// This initializes the worker with specified parameters and ensures that it is properly set up.
		worker := NewWorker("workerSetContext")
		// Assert that the worker instance is not nil.
		// This checks that the worker was successfully created and is not a zero value.
		assert.NotNil(t, worker, "Worker should be successfully created")

		// Create a new background context for testing.
		// This context will be used to set and verify the worker's context.
		ctx := context.Background()

		// Set the worker's context to the new background context.
		// This tests the SetContext method by providing a valid context.
		err := worker.SetContext(ctx)
		// Assert that no error occurred when setting the context.
		// This ensures that the SetContext method works as expected when a valid context is provided.
		assert.NoError(t, err, "Expected no error when setting a valid context")
		// Assert that the worker's context is set correctly.
		// This checks that the worker's context matches the provided context after setting it.
		assert.Equal(t, ctx, worker.workerContext, "Worker context should be set to the provided context")

		// Attempt to set the worker's context to nil.
		// This tests the SetContext method's handling of invalid input.
		err = worker.SetContext(nil)
		// Assert that an error occurred when trying to set a nil context.
		// This verifies that the method correctly returns an error for invalid input.
		assert.Error(t, err, "Expected an error when setting a nil context")

		// Assert that the worker's context remains unchanged after attempting to set a nil context.
		// This verifies that the context does not get altered if a nil value is provided.
		assert.Equal(t, ctx, worker.workerContext, "Worker context should remain unchanged when setting a nil context")
	})

	// GetStatusWithRun tests the behavior of a worker as it transitions through its lifecycle stages.
	// The test verifies that the worker can correctly initialize, process jobs, and handle context
	// cancellation. It checks that the worker starts in an idle state, transitions to running, and
	// eventually stops as expected. Additionally, the test ensures that the worker's error channel
	// is properly closed upon termination and that all goroutines complete without issues.
	t.Run("GetStatusWithRun", func(t *testing.T) {
		// Create a context with cancellation to manage the lifecycle of the worker and ensure proper cleanup.
		// The context will allow the worker to be cancelled if necessary.
		ctx, cancel := context.WithCancel(context.Background())
		// Ensure that the context cancellation function is called at the end of the test.
		// This prevents resource leaks by ensuring proper cleanup after the test completes.
		defer cancel()

		// Create a new Worker instance with a unique name, a timeout of 1 second, and a logger.
		// This initializes the worker with specified parameters and ensures that it is properly set up.
		worker := NewWorker("workerGetStatusWithRun")
		// Assert that the worker instance is not nil.
		// This checks that the worker was successfully created and is not a zero value.
		assert.NotNil(t, worker, "Worker should be successfully created")

		// Set the worker's context to the new background context.
		// This tests the SetContext method by providing a valid context.
		err := worker.SetContext(ctx)
		// Assert that no error occurred when setting the context.
		// This ensures that the SetContext method works as expected when a valid context is provided.
		assert.NoError(t, err, "Expected no error when setting a valid context")

		// Create a channel with a buffer size of 1 to receive tasks.
		// This channel will be used as the job queue for the worker.
		taskQueue := make(chan wr.Task, 1)

		// Set the worker's queue to the open channel.
		// This tests that the worker can successfully use the open channel as its job queue.
		err = worker.SetQueue(taskQueue)
		// Assert that no error is returned when setting an open channel.
		// This confirms that setting an open channel is handled correctly by the worker.
		assert.NoError(t, err, "Setting an open channel should not produce an error")

		// Create a new open channel for error reporting.
		// This channel is intended for use by the worker to report errors encountered during its operations.
		workerErrCh := make(chan *wr.Error)
		// Set the worker's error channel to the newly created open channel.
		// This action configures the worker to use the specified channel for sending error reports.
		// It verifies that the worker can successfully use the provided channel without encountering any errors.
		err = worker.SetWorkerErrChannel(workerErrCh)
		// Assert that no error is returned when setting an open channel.
		// This confirms that the worker's SetWorkerErrChannel method correctly handles the assignment
		// of a valid open channel, ensuring that the channel setup is successful and error-free.
		assert.NoError(t, err, "Setting an open error channel should not produce an error")

		// Increment the WaitGroup counter by 1 to account for the worker's goroutine.
		// This is necessary to properly synchronize the test's main goroutine with the worker's goroutine.
		wg.Add(1)
		// Start the worker in a separate goroutine to allow it to run concurrently.
		// The worker will begin processing tasks in this goroutine.
		go worker.Start(wg)

		// Sleep for a short duration to allow the worker to transition to its initial state.
		// This delay simulates the time needed for the worker to initialize.
		time.Sleep(30 * time.Millisecond)

		// Assert that the worker's initial status is idle.
		// This ensures that the worker is in the expected initial state before processing any jobs.
		assert.Equal(t, wr.StatusWorkerIdle, worker.GetStatus(), "Worker should be idle after starting")

		// Sleep for a short duration to allow the worker to potentially transition to a running state.
		// This provides additional time for the worker to change its status if it starts processing.
		time.Sleep(30 * time.Millisecond)

		// Wait for the worker to stop or time out.
		// This block manages the completion of the worker's lifecycle and handles any potential delays.
		select {
		case <-worker.Stop():
			// Worker completed successfully.
			// Any assertions or checks can be placed here if needed.
			assert.Equal(t, wr.StatusWorkerStopped, worker.GetStatus(), "Expected worker status to be stopped")

			// Use a select statement to receive from the worker's error channel.
			// The select statement allows for non-blocking checks of channel activity.
			select {
			// Attempt to receive from the worker's error channel.
			// If the channel is open and has data, the receive operation will succeed,
			// and `ok` will be true indicating that the channel is still open.
			case _, ok := <-worker.GetError():
				// Assert that the channel is open (ok is true).
				// This ensures that the error channel is functioning correctly and is not closed.
				// The test verifies that the channel is operational, which is critical for proper error reporting.
				assert.True(t, ok, "Error channel should be open and not closed")
			// Default case does nothing; it allows the select statement to proceed without blocking if the channel is not ready.
			default:
			}

		case <-time.After(2 * time.Second):
			t.Error("Worker did not stop within the expected time.")
		}
	})

	// ContextDone tests the worker's behavior when its context is canceled. The test verifies that the worker
	// can properly initialize, process a task, and handle context cancellation. It ensures that the worker
	// correctly transitions to the 'stopped' state upon context cancellation, that its processing state is
	// cleaned up, and that the worker stops within the expected time.
	t.Run("ContextDone", func(t *testing.T) {
		// Create a context with cancellation to manage the lifecycle of the worker and ensure proper cleanup.
		// The context will allow the worker to be cancelled if necessary.
		ctx, cancel := context.WithCancel(context.Background())

		// Create a new Worker instance with a unique name, a timeout of 1 second, and a logger.
		// This initializes the worker with specified parameters and ensures that it is properly set up.
		worker := NewWorker("workerContextDone")
		// Assert that the worker instance is not nil.
		// This checks that the worker was successfully created and is not a zero value.
		assert.NotNil(t, worker, "Worker should be successfully created")

		// Set the worker's context to the new background context.
		// This tests the SetContext method by providing a valid context.
		err := worker.SetContext(ctx)
		// Assert that no error occurred when setting the context.
		// This ensures that the SetContext method works as expected when a valid context is provided.
		assert.NoError(t, err, "Expected no error when setting a valid context")

		// Create a channel with a buffer size of 1 to receive tasks.
		// This channel will be used as the job queue for the worker.
		taskQueue := make(chan wr.Task, 1)

		// Set the worker's queue to the open channel.
		// This tests that the worker can successfully use the open channel as its job queue.
		err = worker.SetQueue(taskQueue)
		// Assert that no error is returned when setting an open channel.
		// This confirms that setting an open channel is handled correctly by the worker.
		assert.NoError(t, err, "Setting an open channel should not produce an error")

		// Set up the mock task to expect a Run call and return without error.
		// This simulates the worker processing the task.
		mockTask.EXPECT().Run().Return()

		// Expect the mock task to have its WaitGroup set to the one created above.
		// This allows synchronization between the task and the worker's lifecycle.
		mockTask.EXPECT().SetWaitGroup(wg).Return(nil)

		// Send the mock task to the worker's task queue.
		// This simulates the worker receiving a task for processing.
		taskQueue <- mockTask

		// Increment the WaitGroup counter by 1 to account for the worker's goroutine.
		// This is necessary to properly synchronize the test's main goroutine with the worker's goroutine.
		wg.Add(1)

		// Start the worker in a separate goroutine to allow it to run concurrently.
		// The worker will begin processing tasks in this goroutine.
		go worker.Start(wg)

		// Wait for 100 millisecond to allow the worker to process the job.
		// This delay provides sufficient time for the worker to handle the job before canceling the context.
		time.Sleep(100 * time.Millisecond)

		// Cancel the context to signal the worker to stop processing.
		// This action is used to test if the worker responds correctly to context cancellation.
		cancel()

		// Wait for the worker to stop processing and check its status.
		// This block waits for either the worker to signal that it has stopped or a timeout to occur.
		select {
		case <-worker.stopCh:
			// Assert that the worker status is 'stopped' after cancellation.
			// This verifies that the worker correctly transitions to the 'stopped' state.
			assert.Equal(t, wr.StatusWorkerStopped, worker.GetStatus(), "Expected worker status to be stopped")

			// Assert that the `process` field of the `worker` is `nil`.
			// This ensures that the worker has not started processing or has properly cleaned up its processing state.
			assert.Nil(t, worker.currentProcess, "Expected worker.process to be nil, indicating that the worker has not started processing or has been properly cleaned up.")

		case <-time.After(5 * time.Second):
			// Timeout case: if the pool does not stop within the expected time, indicate a test failure.
			t.Error("Failed to stop worker within expected time")
		}
	})

	// SuccessStop tests the `Stop` method of the Worker struct to ensure that the worker
	// transitions to the 'stopped' state properly. It verifies that the worker's status
	// is updated to 'stopped', and that both the error channel and stop channel are closed
	// as expected when the worker has finished stopping.
	t.Run("SuccessStop", func(t *testing.T) {
		// Create a background context for the worker.
		// This context will manage the worker's lifecycle and cancellation signals.
		ctx := context.Background()

		// Create a new Worker instance with a unique name, a timeout of 1 second, and a logger.
		// This initializes the worker with specified parameters and ensures that it is properly set up.
		worker := NewWorker("workerSuccessStop")
		// Assert that the worker instance is not nil.
		// This checks that the worker was successfully created and is not a zero value.
		assert.NotNil(t, worker, "Worker should be successfully created")

		// Set the worker's context to the new background context.
		// This tests the SetContext method by providing a valid context.
		err := worker.SetContext(ctx)
		// Assert that no error occurred when setting the context.
		// This ensures that the SetContext method works as expected when a valid context is provided.
		assert.NoError(t, err, "Expected no error when setting a valid context")

		// Create a new open channel for error reporting.
		// This channel is intended for use by the worker to report errors encountered during its operations.
		workerErrCh := make(chan *wr.Error)
		// Set the worker's error channel to the newly created open channel.
		// This action configures the worker to use the specified channel for sending error reports.
		// It verifies that the worker can successfully use the provided channel without encountering any errors.
		err = worker.SetWorkerErrChannel(workerErrCh)
		// Assert that no error is returned when setting an open channel.
		// This confirms that the worker's SetWorkerErrChannel method correctly handles the assignment
		// of a valid open channel, ensuring that the channel setup is successful and error-free.
		assert.NoError(t, err, "Setting an open error channel should not produce an error")

		// Create a channel with a buffer size of 1 to receive tasks.
		// This channel will be used as the job queue for the worker.
		taskQueue := make(chan wr.Task, 1)
		// Set the worker's queue to the open channel.
		// This tests that the worker can successfully use the open channel as its job queue.
		err = worker.SetQueue(taskQueue)
		// Assert that no error is returned when setting an open channel.
		// This confirms that setting an open channel is handled correctly by the worker.
		assert.NoError(t, err, "Setting an open channel should not produce an error")

		select {
		// Wait for the worker to signal that it has stopped.
		// The `select` statement is used to wait for signals from the worker's stop channel,
		// ensuring that we handle the stop notification correctly and verify the worker's status.
		case <-worker.Stop():
			// Assert that the worker status is 'stopped' after cancellation.
			// This verifies that the worker correctly transitions to the 'stopped' state.
			assert.Equal(t, wr.StatusWorkerStopped, worker.GetStatus(), "Expected worker status to be stopped")

			// Use a select statement to receive from the worker's error channel.
			// The select statement allows for non-blocking checks of channel activity.
			select {
			// Attempt to receive from the worker's error channel.
			// If the channel is open and has data, the receive operation will succeed,
			// and `ok` will be true indicating that the channel is still open.
			case _, ok := <-worker.GetError():
				// Assert that the channel is open (ok is true).
				// This ensures that the error channel is functioning correctly and is not closed.
				// The test verifies that the channel is operational, which is critical for proper error reporting.
				assert.True(t, ok, "Error channel should be open and not closed")
			// Default case does nothing; it allows the select statement to proceed without blocking if the channel is not ready.
			default:
			}

			select {
			// Wait for the worker's stop channel to confirm it is closed.
			// The stop channel should be closed as part of the worker's shutdown process.
			// We use this to ensure that the worker has completed all shutdown activities and no further signals will be sent.
			case <-worker.stopCh:
				// Attempt to read from the stop channel to verify that it's closed.
				// Since the channel should be closed, the read operation should succeed and return the zero value of the channel's type.
				_, ok := <-worker.stopCh
				// Assert that the stop channel is indeed closed.
				// If the channel is closed, `ok` should be false, confirming that the worker has fully stopped and cleaned up.
				assert.False(t, ok, "Stop channel should be closed after worker stops")
			}

		case <-time.After(2 * time.Second):
			// If the worker does not stop within the allocated 2 seconds, this block will execute.
			// This indicates that the worker took too long to stop, which could signify a problem with the shutdown process.
			// The test will fail, providing feedback that the worker did not stop as expected within the given time frame.
			t.Error("Failed to stop worker within expected time")
		}
	})

	// WorkerPanic test case ensures that a Worker instance can handle and report a panic
	// that occurs during the execution of a task. This is crucial for validating the robustness
	// of the worker's error handling mechanism, especially in scenarios where unexpected
	// panics might occur. The test verifies that the worker catches the panic, reports the
	// appropriate error, and associates the error with the correct worker instance.
	t.Run("WorkerPanic", func(t *testing.T) {
		// Create a background context for the worker.
		// This context will manage the worker's lifecycle and cancellation signals.
		ctx := context.Background()

		// Create a new Worker instance with a unique name, a timeout of 1 second, and a logger.
		// This initializes the worker with specified parameters and ensures that it is properly set up.
		worker := NewWorker("workerWorkerPanic")
		// Assert that the worker instance is not nil.
		// This checks that the worker was successfully created and is not a zero value.
		assert.NotNil(t, worker, "Worker should be successfully created")

		// Set the worker's context to the new background context.
		// This tests the SetContext method by providing a valid context.
		err := worker.SetContext(ctx)
		// Assert that no error occurred when setting the context.
		// This ensures that the SetContext method works as expected when a valid context is provided.
		assert.NoError(t, err, "Expected no error when setting a valid context")

		// Create a new open channel for error reporting.
		// This channel is intended for use by the worker to report errors encountered during its operations.
		workerErrCh := make(chan *wr.Error)
		// Set the worker's error channel to the newly created open channel.
		// This action configures the worker to use the specified channel for sending error reports.
		// It verifies that the worker can successfully use the provided channel without encountering any errors.
		err = worker.SetWorkerErrChannel(workerErrCh)
		// Assert that no error is returned when setting an open channel.
		// This confirms that the worker's SetWorkerErrChannel method correctly handles the assignment
		// of a valid open channel, ensuring that the channel setup is successful and error-free.
		assert.NoError(t, err, "Setting an open error channel should not produce an error")

		// Create a channel with a buffer size of 1 to receive tasks.
		// This channel will be used as the job queue for the worker.
		taskQueue := make(chan wr.Task, 1)

		// Set the worker's queue to the open channel.
		// This tests that the worker can successfully use the open channel as its job queue.
		err = worker.SetQueue(taskQueue)
		// Assert that no error is returned when setting an open channel.
		// This confirms that setting an open channel is handled correctly by the worker.
		assert.NoError(t, err, "Setting an open channel should not produce an error")

		// Create an instance of MockPanicTask, which simulates a task that will panic during its execution.
		// This mock task is used to test the worker's panic handling capabilities.
		mockPanicTask := &MockPanicTask{}

		// Send the mock panic task to the worker's task queue.
		// This simulates the worker receiving a task that will cause a panic when executed.
		taskQueue <- mockPanicTask

		// Increment the WaitGroup counter by 1 to account for the worker's goroutine.
		// This is necessary to properly synchronize the test's main goroutine with the worker's goroutine.
		wg.Add(1)

		// Start a new goroutine to handle the delayed start of the worker.
		// This goroutine allows the worker to begin processing tasks independently of the main test execution.
		go func() {
			// Introduce a delay of 1 second before starting the worker.
			// This delay simulates a real-world scenario where the worker might not start immediately after initialization.
			<-time.After(1 * time.Second)

			// Begin the worker's task processing.
			// The worker will start processing tasks from its queue and handle any errors or panics that occur.
			// The `wg` (WaitGroup) is passed to ensure that the test waits for the worker to finish before proceeding.
			worker.Start(wg)
		}()

		select {
		// Wait for the worker to handle the task and check for errors or a timeout.
		// This select block listens for the worker to signal that it encountered an error or waits for a timeout.
		case workerError := <-worker.GetError():
			// Assert that the error received is the expected panic error.
			// This verifies that the worker correctly identified and reported the panic error.
			assert.ErrorIs(t, workerError.Error, errMockPanic)
			// Assert that the error instance matches the worker that encountered the error.
			// This confirms that the correct worker is associated with the reported error.
			assert.Equal(t, worker, workerError.Instance)

		case <-time.After(5 * time.Second):
			// If the worker does not stop within the allocated 5 seconds, this block will execute.
			// This indicates that the worker took too long to stop, which could signify a problem with the shutdown process.
			// The test will fail, providing feedback that the worker did not stop as expected within the given time frame.
			t.Error("Failed to stop worker within expected time")
		}

	})

	// RestartWorker tests the behavior of the `Restart` method for a worker in the worker pool system.
	// It ensures that the worker can be restarted correctly and that the retry count is incremented as expected.
	// Additionally, it verifies that the worker transitions to an idle state upon restart and properly shuts down
	// when stopped. The test checks that the worker's status and retry count match the expected values after the restart
	// operation and confirms that the worker's error channel is closed after stopping.
	t.Run("RestartWorker", func(t *testing.T) {
		// Create a context with cancellation to manage the lifecycle of the worker and ensure proper cleanup.
		// The context will allow the worker to be cancelled if necessary.
		ctx, cancel := context.WithCancel(context.Background())
		// Ensure that the context cancellation function is called at the end of the test.
		// This prevents resource leaks by ensuring proper cleanup after the test completes.
		defer cancel()

		// retryCount represents the number of times an operation should be retried
		// in case of failure. Here, it is initialized to 1, meaning the operation
		// will be attempted once before considering it a failure. This value can
		// be adjusted based on the desired retry strategy to handle transient errors.
		retryCount := int32(1)

		// Create a new Worker instance with unique name, a timeout of 1 second, and a logger.
		// This initializes the worker with specified parameters and ensures that it is properly set up.
		worker := NewWorker("workerRestartWorker")
		// Assert that the worker instance is not nil.
		// This checks that the worker was successfully created and is not a zero value.
		assert.NotNil(t, worker, "Worker should be successfully created")

		// Assert that the initial retry count of the worker is zero.
		// This verifies that the worker starts with a retry count of zero before any restarts occur.
		assert.Equal(t, int32(0), worker.GetRetry(), "Worker retry count should be zero initially")

		// Set the worker's context to the new background context.
		// This tests the SetContext method by providing a valid context.
		err := worker.SetContext(ctx)
		// Assert that no error occurred when setting the context.
		// This ensures that the SetContext method works as expected when a valid context is provided.
		assert.NoError(t, err, "Expected no error when setting a valid context")

		// Create a new open channel for error reporting.
		// This channel is intended for use by the worker to report errors encountered during its operations.
		workerErrCh := make(chan *wr.Error)
		// Set the worker's error channel to the newly created open channel.
		// This action configures the worker to use the specified channel for sending error reports.
		// It verifies that the worker can successfully use the provided channel without encountering any errors.
		err = worker.SetWorkerErrChannel(workerErrCh)
		// Assert that no error is returned when setting an open channel.
		// This confirms that the worker's SetWorkerErrChannel method correctly handles the assignment
		// of a valid open channel, ensuring that the channel setup is successful and error-free.
		assert.NoError(t, err, "Setting an open error channel should not produce an error")

		// Create a channel with a buffer size of 1 to receive tasks.
		// This channel will be used as the job queue for the worker.
		taskQueue := make(chan wr.Task, 1)

		// Set the worker's queue to the open channel.
		// This tests that the worker can successfully use the open channel as its job queue.
		err = worker.SetQueue(taskQueue)
		// Assert that no error is returned when setting an open channel.
		// This confirms that setting an open channel is handled correctly by the worker.
		assert.NoError(t, err, "Setting an open channel should not produce an error")

		// Increment the WaitGroup counter by 1 to account for the worker's goroutine.
		// This is necessary to properly synchronize the test's main goroutine with the worker's goroutine.
		wg.Add(1)
		// Start the worker in a separate goroutine to allow it to run concurrently.
		// The worker will begin processing tasks in this goroutine.
		go worker.Restart(wg)

		// Sleep for a short duration to allow the worker to transition to its initial state.
		// This delay simulates the time needed for the worker to initialize.
		time.Sleep(10 * time.Millisecond)

		// Assert that the worker's initial status is idle.
		// This ensures that the worker is in the expected initial state before processing any jobs.
		assert.Equal(t, wr.StatusWorkerIdle, worker.GetStatus(), "Worker should be idle after starting")

		// Assert that the worker's retry count matches the expected value.
		// This checks that the worker's restart process has incremented the retry count correctly.
		assert.Equal(t, retryCount, worker.GetRetry(), "Worker retry count should match the expected retry count")

		// Wait for the worker to stop or time out.
		// This block manages the completion of the worker's lifecycle and handles any potential delays.
		select {
		case <-worker.Stop():
			// Worker completed successfully.
			// Any assertions or checks can be placed here if needed.
			assert.Equal(t, wr.StatusWorkerStopped, worker.GetStatus(), "Expected worker status to be stopped")

			// Use a select statement to receive from the worker's error channel.
			// The select statement allows for non-blocking checks of channel activity.
			select {
			// Attempt to receive from the worker's error channel.
			// If the channel is open and has data, the receive operation will succeed,
			// and `ok` will be true indicating that the channel is still open.
			case _, ok := <-worker.GetError():
				// Assert that the channel is open (ok is true).
				// This ensures that the error channel is functioning correctly and is not closed.
				// The test verifies that the channel is operational, which is critical for proper error reporting.
				assert.True(t, ok, "Error channel should be open and not closed")
			// Default case does nothing; it allows the select statement to proceed without blocking if the channel is not ready.
			default:
			}

		case <-time.After(2 * time.Second):
			t.Error("Worker did not stop within the expected time.")
		}
	})
}
